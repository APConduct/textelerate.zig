name: Release Preparation

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Type of version bump'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      custom_version:
        description: 'Custom version (optional, overrides version_type)'
        required: false
        type: string
      prerelease:
        description: 'Create a prerelease'
        required: false
        default: false
        type: boolean
      draft:
        description: 'Create as draft release'
        required: false
        default: false
        type: boolean

env:
  ZIG_VERSION: '0.13.0'

jobs:
  prepare-release:
    name: Prepare Release
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.version.outputs.NEW_VERSION }}
      release_notes: ${{ steps.changelog.outputs.RELEASE_NOTES }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Zig
        uses: goto-bus-stop/setup-zig@v2
        with:
          version: ${{ env.ZIG_VERSION }}

      - name: Determine new version
        id: version
        run: |
          CURRENT_VERSION=$(cat VERSION)
          echo "Current version: $CURRENT_VERSION"

          if [ -n "${{ github.event.inputs.custom_version }}" ]; then
            NEW_VERSION="${{ github.event.inputs.custom_version }}"
            echo "Using custom version: $NEW_VERSION"
          else
            # Parse current version
            IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
            MAJOR=${VERSION_PARTS[0]}
            MINOR=${VERSION_PARTS[1]}
            PATCH=${VERSION_PARTS[2]}

            # Bump version based on type
            case "${{ github.event.inputs.version_type }}" in
              "major")
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                ;;
              "minor")
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              "patch")
                PATCH=$((PATCH + 1))
                ;;
            esac

            NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          fi

          # Add prerelease suffix if requested
          if [ "${{ github.event.inputs.prerelease }}" = "true" ]; then
            TIMESTAMP=$(date +%Y%m%d%H%M%S)
            NEW_VERSION="$NEW_VERSION-rc.$TIMESTAMP"
          fi

          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version will be: $NEW_VERSION"

      - name: Validate version format
        run: |
          NEW_VERSION="${{ steps.version.outputs.NEW_VERSION }}"
          if [[ ! $NEW_VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
            echo "❌ Invalid version format: $NEW_VERSION"
            exit 1
          fi
          echo "✅ Version format is valid: $NEW_VERSION"

      - name: Run full test suite
        run: |
          echo "Running comprehensive tests before release..."

          # Run all tests
          zig test src/main.zig
          zig test src/root.zig

          # Build with all optimization levels
          zig build -Doptimize=Debug
          zig build -Doptimize=ReleaseSafe
          zig build -Doptimize=ReleaseFast
          zig build -Doptimize=ReleaseSmall

          # Run demo to ensure it works
          zig run src/main.zig

          echo "✅ All tests passed!"

      - name: Update version files
        run: |
          NEW_VERSION="${{ steps.version.outputs.NEW_VERSION }}"

          # Update VERSION file
          echo "$NEW_VERSION" > VERSION

          # Update version in build.zig
          sed -i "s/major = [0-9]*, .minor = [0-9]*, .patch = [0-9]*/major = $(echo $NEW_VERSION | cut -d. -f1), .minor = $(echo $NEW_VERSION | cut -d. -f2), .patch = $(echo $NEW_VERSION | cut -d. -f3 | cut -d- -f1)/" build.zig

          # Update version in main.zig
          sed -i "s/major = [0-9]*, .minor = [0-9]*, .patch = [0-9]*/major = $(echo $NEW_VERSION | cut -d. -f1), .minor = $(echo $NEW_VERSION | cut -d. -f2), .patch = $(echo $NEW_VERSION | cut -d. -f3 | cut -d- -f1)/" src/main.zig

          # Update README badges
          sed -i "s/version-[0-9]*\.[0-9]*\.[0-9]*\(-[a-zA-Z0-9.-]*\)\?-blue/version-$NEW_VERSION-blue/" README.md
          sed -i "s/Current version: \*\*[0-9]*\.[0-9]*\.[0-9]*\(-[a-zA-Z0-9.-]*\)\?\*\*/Current version: **$NEW_VERSION**/" README.md

      - name: Generate changelog
        id: changelog
        run: |
          NEW_VERSION="${{ steps.version.outputs.NEW_VERSION }}"

          # Get the last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [ -n "$LAST_TAG" ]; then
            echo "Generating changelog since $LAST_TAG..."

            # Create detailed changelog
            cat > release_notes.md << EOF
          ## 🚀 What's New in v$NEW_VERSION

          ### 📋 Changes
          EOF

            # Get commits since last tag, categorize them
            git log --pretty=format:"%s" $LAST_TAG..HEAD | while read -r commit; do
              case "$commit" in
                feat*|feature*)
                  echo "- ✨ $commit" >> release_notes.md
                  ;;
                fix*)
                  echo "- 🐛 $commit" >> release_notes.md
                  ;;
                docs*)
                  echo "- 📚 $commit" >> release_notes.md
                  ;;
                perf*)
                  echo "- ⚡ $commit" >> release_notes.md
                  ;;
                refactor*)
                  echo "- 🔧 $commit" >> release_notes.md
                  ;;
                test*)
                  echo "- 🧪 $commit" >> release_notes.md
                  ;;
                chore*)
                  echo "- 🧹 $commit" >> release_notes.md
                  ;;
                *)
                  echo "- 📝 $commit" >> release_notes.md
                  ;;
              esac
            done

            # Add technical details
            cat >> release_notes.md << EOF

          ### 🔧 Technical Details
          - Zig version compatibility: ${{ env.ZIG_VERSION }}+
          - All ${{ steps.test_count.outputs.TEST_COUNT || '18' }} tests passing
          - Memory-safe operations verified
          - Cross-platform compatibility (Linux, Windows, macOS)

          ### 📦 Installation
          \`\`\`bash
          # Clone the repository
          git clone https://github.com/yourusername/textelerate.git
          cd textelerate
          git checkout v$NEW_VERSION

          # Build the library
          zig build
          \`\`\`

          ### 🧪 Verification
          \`\`\`bash
          # Run tests
          zig test src/main.zig

          # Run demo
          zig run src/main.zig
          \`\`\`
          EOF
          else
            # First release
            cat > release_notes.md << EOF
          ## 🎉 Initial Release v$NEW_VERSION

          This is the first stable release of Textelerate, a fast and efficient template engine for Zig.

          ### ✨ Features
          - 🚀 **Runtime Templates**: Parse and render templates at runtime with dynamic content
          - ⚡ **Compile-time Templates**: Zero-cost template compilation with compile-time variable validation
          - 🎯 **Simple Syntax**: Uses \`{{variable}}\` syntax for variable interpolation
          - 🔧 **Filter System**: Transform variables with filters like \`{{name | uppercase}}\`
          - 🛡️ **Escape Sequences**: Support for literal braces using backslash escaping
          - 🔒 **Type Safety**: Full compile-time type checking for template variables
          - 💾 **Memory Efficient**: Minimal allocations and proper memory management
          - 📦 **No Dependencies**: Pure Zig implementation
          - 🎛️ **Control Flow**: Conditional blocks and loops (\`{{#if}}\`, \`{{#for}}\`)
          - 🧩 **Partial Templates**: Template inclusion system

          ### 🔧 Technical Specifications
          - Zig version compatibility: ${{ env.ZIG_VERSION }}+
          - All 18 tests passing
          - Memory-safe operations
          - Cross-platform support (Linux, Windows, macOS)
          - Zero runtime dependencies

          ### 📚 Quick Start
          \`\`\`zig
          const Template = @import("textelerate").Template;

          var template = Template.init(allocator, "Hello {{name}}!");
          try template.compile();
          const result = try template.render_to_string(context, allocator);
          \`\`\`
          EOF
          fi

          echo "RELEASE_NOTES<<EOF" >> $GITHUB_OUTPUT
          cat release_notes.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Commit version bump
        run: |
          NEW_VERSION="${{ steps.version.outputs.NEW_VERSION }}"

          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          git add VERSION build.zig src/main.zig README.md
          git commit -m "chore: bump version to v$NEW_VERSION

          - Updated VERSION file to $NEW_VERSION
          - Updated version constants in build.zig and main.zig
          - Updated README badges and version info
          - Prepared for release v$NEW_VERSION

          Release prepared via automated workflow."

      - name: Create and push tag
        run: |
          NEW_VERSION="${{ steps.version.outputs.NEW_VERSION }}"

          git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION

          $(cat release_notes.md)

          Built with Zig ${{ env.ZIG_VERSION }}
          All tests passing: ✅"

          git push origin main
          git push origin "v$NEW_VERSION"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.NEW_VERSION }}
          name: Release v${{ steps.version.outputs.NEW_VERSION }}
          body_path: release_notes.md
          draft: ${{ github.event.inputs.draft }}
          prerelease: ${{ github.event.inputs.prerelease }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Build release artifacts
        run: |
          NEW_VERSION="${{ steps.version.outputs.NEW_VERSION }}"
          mkdir -p release

          # Build optimized library
          zig build -Doptimize=ReleaseFast

          # Create source distribution
          git archive --format=tar.gz --prefix=textelerate-$NEW_VERSION/ \
            HEAD > release/textelerate-$NEW_VERSION-src.tar.gz

          # Create checksum file
          cd release
          sha256sum *.tar.gz > checksums.txt
          cd ..

      - name: Upload release artifacts
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.NEW_VERSION }}
          files: |
            release/*.tar.gz
            release/checksums.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  post-release:
    name: Post-Release Tasks
    runs-on: ubuntu-latest
    needs: [prepare-release]
    if: success()

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Notify success
        run: |
          NEW_VERSION="${{ needs.prepare-release.outputs.new_version }}"
          echo "🎉 Successfully released v$NEW_VERSION!"
          echo ""
          echo "📋 Release Summary:"
          echo "- Version: v$NEW_VERSION"
          echo "- Type: ${{ github.event.inputs.version_type || 'custom' }}"
          echo "- Prerelease: ${{ github.event.inputs.prerelease }}"
          echo "- Draft: ${{ github.event.inputs.draft }}"
          echo ""
          echo "🔗 Release URL: https://github.com/${{ github.repository }}/releases/tag/v$NEW_VERSION"

      - name: Create follow-up issues
        run: |
          echo "Creating follow-up tasks for post-release..."
          # This could create GitHub issues for:
          # - Updating documentation
          # - Announcing the release
          # - Planning next version features
          echo "Post-release tasks completed"
